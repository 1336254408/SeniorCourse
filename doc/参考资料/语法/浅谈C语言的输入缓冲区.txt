	前两天我在写一个程序的时候，想要用getchar函数来实现暂停程序的功能，可是实测表明根本不行。我感到非常尴尬，毕竟这个程序和我想象中只有这么一点差别，离成功只有一步之遥，但这一点差别又让我不知所措。尝试了很多方法都不行，差点崩溃。接下来，我查阅相关资料，分析出问题所在，上机测试，苦战三回合，顺利地完成了程序。希望我的经验能帮助一些人少走弯路。

	这篇心得主要分享scanf、getchar读取数据的原理和这种原理对我们编程的影响，以及它的避免负面效果的方法，由于认识得很浅，所以只能算是浅谈，如果有什么不足或错误的地方，欢迎指出。scanf函数和getchar函数的读取数据的方式都是缓冲读，并不是即时的。也就是说，当运行到scanf或者getchar函数时，先等待用户输入数据，将这些数据存入一个缓冲区（buffer）里面，当接收到回车时才开始读入数据。毫无疑问，这样的缓冲读数据的方式是有它的好处的。比如：用户想输入123这个数据，如果scanf函数在接收到1的时候就开始读数据，那么实际被读取的数据就是1，这样的话，就无法实现输入123。正是这种建立缓冲区的读取数据的方式，在方便我们的同时给我们带来了一些麻烦。

	比如说有这么一段代码：
#include <stdio.h> 
int main()
{
	char a;
	a=getchar();
	printf("%c",a);
	scanf("%c",&a);
	printf("%c",a);
	return 0;
}

	我们设计这段代码是为了让程序实现以下功能：先输入a的值，然后将之输出，然后再次输入a的值，再次输出，也就是两次输入两次输出。可是程序运行的结果却让我们觉得很奇怪。比如：输入12回车，屏幕上会显示12，然后就结束了。之所以出现这样的情况，不是编译器出了问题，而是缓冲区在作怪。我们输入‘1’‘2’‘回车’，一共三个字符，这些字符都被放进了缓冲区里面，程序运行到getchar函数时，只取走了第一个字符‘1’，‘2’和‘回车’继续留在缓冲区里，当程序运行到scanf语句时，由于缓冲区里有‘回车’字符，所以scanf函数直接开始从缓冲区里读入数据，而不是等待用户输入了。

	这种现象的存在有时对我们有着不好的效果。比如，本来getchar函数可以用来暂停程序，可是由于缓冲区的存在，这种暂停效果就时灵时不灵了，以下代码的运行结果就能验证这一点：
#include <stdio.h> 
int main()
{
	char a;
	a=getchar();
	printf("%c",a);
	getchar();
	return 0;
}

	请大家尝试编译运行这个程序，如果输入1回车会有怎样的效果。在编译器上的运行的话，感觉不出有什么问题，因为编译器会自动暂停让你观察运行结果。可是如果在编译器的目录下找到debug文件夹里面的目标程序，再重新运行，就能够发现，这个程序打开之后秒退，这说明这个程序运行的过程中getchar函数没能起到暂停的效果。
当摸清了问题的本质，解决的办法就层出不穷了，这里介绍四种。

	第一种办法：把第一段代码的scanf语句写成：scanf("空格%c",&a);或者scanf("\n%c",&a);。这种办法的原理并不是清除了缓冲区，而是跳过了回车符，具体原理可以参考教材的格式化输入的相关部分。

	第二种办法：把第一段代码的scanf语句写成：scanf("%*c%c");这种办法的原理是格式化输入中的赋值抑制，同样可以参考教材的相关内容。

	第三种办法：在第一段代码的a=getchar();和scanf("%c",&a);之间再添加一句getchar();这种办法的原理是用新增的getchar();来接收缓冲区残留的回车符，间接达到清空缓冲区的作用。

第四种办法：使用fflush()函数，我们可以在第一段代码的a=getchar();的下一行加上一句rewind(stdin);这样就相当于清空了缓冲区。

第四种方法是万能的，但是前三种也有各自的好处，具体用法需大家自己体会。另外，还有一种用gets函数解决的办法，与第三种办法类似，有兴趣的同学可以自行探索。